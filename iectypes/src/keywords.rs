//! IEC 61131-3 Reserved Words and Keywords
//!
//! Reference: IEC 61131-3, Annex B - Formal specification

/// Check if a string is an IEC 61131-3 reserved keyword
pub fn is_keyword(s: &str) -> bool {
    KEYWORDS.binary_search(&s.to_uppercase().as_str()).is_ok()
}

/// Check if a string is a standard function name
pub fn is_standard_function(s: &str) -> bool {
    STANDARD_FUNCTIONS
        .binary_search(&s.to_uppercase().as_str())
        .is_ok()
}

/// IEC 61131-3 Reserved Keywords (sorted for binary search)
pub static KEYWORDS: &[&str] = &[
    "ACTION",
    "AND",
    "ARRAY",
    "AT",
    "BY",
    "CASE",
    "CONFIGURATION",
    "CONSTANT",
    "DATE",
    "DATE_AND_TIME",
    "DINT",
    "DO",
    "DT",
    "DWORD",
    "ELSE",
    "ELSIF",
    "END_ACTION",
    "END_CASE",
    "END_CONFIGURATION",
    "END_FOR",
    "END_FUNCTION",
    "END_FUNCTION_BLOCK",
    "END_IF",
    "END_PROGRAM",
    "END_REPEAT",
    "END_RESOURCE",
    "END_STEP",
    "END_STRUCT",
    "END_TRANSITION",
    "END_TYPE",
    "END_VAR",
    "END_WHILE",
    "EXIT",
    "FALSE",
    "FOR",
    "FROM",
    "FUNCTION",
    "FUNCTION_BLOCK",
    "IF",
    "INITIAL_STEP",
    "INT",
    "INTERVAL",
    "LDATE",
    "LDATE_AND_TIME",
    "LDT",
    "LINT",
    "LREAL",
    "LTIME",
    "LTIME_OF_DAY",
    "LTOD",
    "LWORD",
    "MOD",
    "NON_RETAIN",
    "NOT",
    "OF",
    "ON",
    "OR",
    "PRIORITY",
    "PROGRAM",
    "READ_ONLY",
    "READ_WRITE",
    "REAL",
    "REPEAT",
    "RESOURCE",
    "RETAIN",
    "RETURN",
    "SINGLE",
    "SINT",
    "STEP",
    "STRING",
    "STRUCT",
    "TASK",
    "THEN",
    "TIME",
    "TIME_OF_DAY",
    "TO",
    "TOD",
    "TRANSITION",
    "TRUE",
    "TYPE",
    "UDINT",
    "UINT",
    "ULINT",
    "UNTIL",
    "USINT",
    "VAR",
    "VAR_ACCESS",
    "VAR_CONFIG",
    "VAR_EXTERNAL",
    "VAR_GLOBAL",
    "VAR_IN_OUT",
    "VAR_INPUT",
    "VAR_OUTPUT",
    "VAR_TEMP",
    "WHILE",
    "WITH",
    "WORD",
    "WSTRING",
    "XOR",
];

/// Standard Functions (sorted for binary search)
pub static STANDARD_FUNCTIONS: &[&str] = &[
    // Sorted alphabetically for binary_search
    "ABS",
    "ACOS",
    "ADD",
    "AND",
    "ASIN",
    "ATAN",
    "BOOL_TO_BYTE",
    "BOOL_TO_DINT",
    "BOOL_TO_DWORD",
    "BOOL_TO_INT",
    "BOOL_TO_LINT",
    "BOOL_TO_LREAL",
    "BOOL_TO_LWORD",
    "BOOL_TO_REAL",
    "BOOL_TO_SINT",
    "BOOL_TO_UDINT",
    "BOOL_TO_UINT",
    "BOOL_TO_ULINT",
    "BOOL_TO_USINT",
    "BOOL_TO_WORD",
    "BYTE_TO_BOOL",
    "BYTE_TO_DINT",
    "BYTE_TO_INT",
    "BYTE_TO_SINT",
    "BYTE_TO_USINT",
    "CONCAT",
    "COS",
    "CTD",
    "CTU",
    "CTUD",
    "DELETE",
    "DINT_TO_BOOL",
    "DINT_TO_BYTE",
    "DINT_TO_INT",
    "DINT_TO_REAL",
    "DINT_TO_SINT",
    "DINT_TO_STRING",
    "DIV",
    "DWORD_TO_BOOL",
    "DWORD_TO_DINT",
    "DWORD_TO_REAL",
    "EQ",
    "EXP",
    "EXPT",
    "FIND",
    "F_TRIG",
    "GE",
    "GT",
    "INSERT",
    "INT_TO_BOOL",
    "INT_TO_BYTE",
    "INT_TO_DINT",
    "INT_TO_REAL",
    "INT_TO_SINT",
    "INT_TO_STRING",
    "LE",
    "LEFT",
    "LEN",
    "LIMIT",
    "LN",
    "LOG",
    "LREAL_TO_DINT",
    "LREAL_TO_INT",
    "LREAL_TO_REAL",
    "LREAL_TO_STRING",
    "LT",
    "MAX",
    "MID",
    "MIN",
    "MOD",
    "MOVE",
    "MUL",
    "MUX",
    "NE",
    "NEG",
    "NOT",
    "OR",
    "REAL_TO_DINT",
    "REAL_TO_INT",
    "REAL_TO_LREAL",
    "REAL_TO_STRING",
    "REPLACE",
    "RIGHT",
    "ROL",
    "ROR",
    "RS",
    "R_TRIG",
    "SEL",
    "SHL",
    "SHR",
    "SIN",
    "SINT_TO_BOOL",
    "SINT_TO_BYTE",
    "SINT_TO_DINT",
    "SINT_TO_INT",
    "SQRT",
    "SR",
    "STRING_TO_DINT",
    "STRING_TO_INT",
    "STRING_TO_LREAL",
    "STRING_TO_REAL",
    "SUB",
    "TAN",
    "TOF",
    "TON",
    "TP",
    "TRUNC",
    "XOR",
];

/// IEC 61131-3 operator keywords
pub static OPERATORS: &[&str] = &["AND", "MOD", "NOT", "OR", "XOR"];

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_is_keyword() {
        assert!(is_keyword("IF"));
        assert!(is_keyword("if"));
        assert!(is_keyword("FUNCTION_BLOCK"));
        assert!(!is_keyword("myVariable"));
    }

    #[test]
    fn test_is_standard_function() {
        assert!(is_standard_function("ABS"));
        assert!(is_standard_function("sin"));
        assert!(is_standard_function("TON"));
        assert!(!is_standard_function("MyFunc"));
    }
}
